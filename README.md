# engsoftwaremoderna

O livro Engenharia de Software Moderna, foi escrito pelo Professor Marco Tulio Valente e é um guia para os principais conceitos que rondam o mundo da engenharia de software, desde diagramação de software até modelagem e padrões de software.
No capítulo 6 o livro aborda os padrões de projeto inseridos no contexto do desenvolvimento de software e discute em dez seções separadas, dez padrões de projetos diferentes, sendo eles: Fábrica, Singleton, Proxy, Adaptador, Fachada, Decorador, Strategy, Observador, Template Method e Visitor. Na introdução do capítulo 6 o autor disserta sobre os padrões de projeto num geral e como são importantes no desenvolvimento e fabricação de um software dizendo que padrões de projeto visam a criação de projetos de software flexíveis e extensíveis. Segundo o autor um desenvolvedor pode se beneficiar dos padrões de projeto numa implementação de um próprio sistema ou até mesmo em sistemas de terceiros, que já utilizem algum padrão de projeto conhecido. O primeiro padrão apresentado é o padrão Fábrica, que é descrito como uma solução que possui algumas variações, mas no caso apresentado é implementado um método estático que: (1) apenas cria e retorna objetos de uma determinada classe; (2) e também oculta o tipo desses objetos por trás de uma interface. Dizendo de outra forma, um método fábrica estático funciona como um aspirador de métodos new: todas as chamadas antigas de new migram para uma única chamada, no método fábrica estático. Após isso, somos introduzidos ao Singleton, esse padrão de projeto define como implementar classes que terão, como o próprio nome indica, no máximo uma instância. É dito que o Singleton é um dos padrões de projeto mais criticados por poder ser usado para camuflar a criação de variáveis e estruturais de acesso global, que geralmente representam acoplamento forte entre classes. O próximo padrão apresentado é o Proxy, que defende a inserção de um objeto intermediário, chamado proxy, entre um objeto base e seus clientes. Dessa forma, o objetivo desse padrão é sempre mediar o acesso a um objeto base, agregando as funcionalidades sem que o mesmo tome conhecimento disso, além disso é citado a utilização do proxy para atingimento de outros requisitos não funcionais como criação de stubs para comunicação com cliente remoto. O padrão seguinte é o Adaptador, também conhecido como Wrapper, recomenda-se usar esse padrão quando temos que converter a interface de uma classe para outra interface, esperada pelos seus clientes. Depois disso o autor nos introduz ao padrão Fachada que é, como o nome sugere uma classe que oferece uma interface mais simples para um sistema. Com o objetivo de evitar que usuários possuam conhecimento sobre classes internas e sensíveis do sistema, que ficam encapsuladas por trás da Fachada. Passamos agora ao Decorador, que representa uma alternativa a herança quando se precisa adicionar novas funcionalidades em uma classe base. Em vez de usar herança, usa-se composição para adicionar tais funcionalidades dinamicamente nas classes base. Dessa forma evitamos a utilização de herança com outra alternativa. Seguimos com o padrão Strategy, que tem como objetivo parametrizar os algoritmos usados por uma classe. Ele prescreve como encapsular uma família de algoritmos e como torná-los intercambiáveis. Assim, seu uso é recomendado quando uma classe é usuária de um certo algoritmo. Agora vamos ao Observador, que é um padrão que define como implementar uma relação do tipo um-para-muitos entre objetos sujeito e observadores, dessa forma, pode-se citar como grandes vantagens o não acoplamento dos sujeitos a seus observadores, esse comportamento facilita o uso e reúso do sujeitos em diversos cenários diferentes. Seguimos para o Template Method que especifica como implementar o esqueleto de um algoritmo em uma classe abstrata X, mas deixando pendente alguns passos — ou métodos abstratos, ele é fundamental, por exemplo, para implementação de frameworks, isto é, aplicações semi-prontas, que antes de serem usadas devem ser customizadas por seus clientes. O autor finaliza os exemplos específicos de padrões com o Visitor, que define como adicionar uma operação em uma família de objetos, sem que seja preciso modificar as classes dos mesmos. Além disso, o padrão Visitor deve funcionar mesmo em linguagens com single dispatching de métodos, como Java. Após a dissertação sobre os dez padrões de projetos anteriormente citados, o autor cita outros padrões numa seção a parte, como o Iterador que padroniza uma interface para caminhar sobre uma estrutura de dados e o Builder que facilita a instanciação de objetos que têm muitos atributos, sendo alguns deles opcionais. Após isso, o professor cita quando não deve ser feita a utilização de padrões de projeto, ele diz que na maioria das vezes a razão pela não utilização é que assim como tudo na computação, padrões de projeto possuem um custo. Afinal em muitos sistemas se percebe a utilização exagerada de padrões de projeto em contextos que poderiam ser resolvidos de maneira mais simples.
